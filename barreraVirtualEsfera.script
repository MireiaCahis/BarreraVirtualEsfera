def barreraVirtualEsfera():
  global _hidden_verificationVariable=0
  step_count_b7235f0a_cbb2_4c42_8fc8_6f2b845147a7 = 0.0
  thread Step_Counter_Thread_6ee0f1eb_1164_4362_bee5_6726ac1a9d95():
    while (True):
      step_count_b7235f0a_cbb2_4c42_8fc8_6f2b845147a7 = step_count_b7235f0a_cbb2_4c42_8fc8_6f2b845147a7 + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_6ee0f1eb_1164_4362_bee5_6726ac1a9d95()
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  set_safety_mode_transition_hardness(1)
  set_gravity([0.0, 0.0, 9.82])
  set_target_payload(0.000000, [0.000000, 0.000000, 0.000000], [0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000])
  set_tcp(p[0.0,0.0,0.145,0.0,0.0,0.0])
  set_tool_communication(False, 115200, 0, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(0)
  global Plane_1=p[-0.1368615374780743,-0.25928082173531203,0.2504135943406838,-5.2917103496771535E-11,-4.180449287005053E-11,1.570796326752836]
  global Plane_2=p[-0.1742088076450252,-0.2,0.02622608731903274,1.570796326794897,5.089570548264191E-11,5.41594168576528E-11]
  global Point_1=p[-0.13686153749022492,-0.3193814880431104,0.3187602624678359,0.5536180370159867,1.9121181481894585,-1.831476432614759]
  global Point_2=p[-0.13686153751823135,-0.26718082172328733,0.031817929521107666,-0.0012213596567563713,3.11627652848082,0.03889191563370371]
  def calculate_point_to_move_towards(feature, direction, position_distance):
    local posDir=[direction[0], direction[1], direction[2]]
    if (norm(posDir) < 1e-6):
      return get_target_waypoint()
    end
    local direction_vector_normalized=normalize(posDir)
    local displacement_pose=p[direction_vector_normalized[0] * position_distance,direction_vector_normalized[1] * position_distance,direction_vector_normalized[2] * position_distance,0,0,0]
    local wanted_displacement_in_base_frame=pose_sub(pose_trans(feature, displacement_pose), feature)
    return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
  end
  $ 73 "Thread_1"
  thread Thread_1():
    while (True):
      $ 74 "Loop"
      while (True):
        $ 75 "'Obtenim les posicions del TCP i el toolFlange'"
        # 'Obtenim les posicions del TCP i el toolFlange'
        $ 76 "llistaPosTCP≔get_actual_tcp_pose()"
        global llistaPosTCP= get_actual_tcp_pose ()
        $ 77 "llistaPosTool≔get_actual_tool_flange_pose()"
        global llistaPosTool=get_actual_tool_flange_pose()
        $ 78 "'Obtenim el punt intermig.'"
        # 'Obtenim el punt intermig.'
        $ 79 "llistaPosMig≔p[(llistaPosTCP[0]+llistaPosTool[0])/2,(llistaPosTCP[1]+llistaPosTool[1])/2,(llistaPosTCP[2]+llistaPosTool[2])/2,llistaPosTCP[3],llistaPosTCP[4],llistaPosTCP[5]]"
        global llistaPosMig=p[(llistaPosTCP[0]+llistaPosTool[0])/2,(llistaPosTCP[1]+llistaPosTool[1])/2,(llistaPosTCP[2]+llistaPosTool[2])/2,llistaPosTCP[3],llistaPosTCP[4],llistaPosTCP[5]]
        $ 80 "'Calculem la distancia entre dos punts, el centre i el tcp, toolFlange o punt del mig.'"
        # 'Calculem la distancia entre dos punts, el centre i el tcp, toolFlange o punt del mig.'
        $ 81 "distPunts≔radiTCP+sqrt(pow(llistaPosTCP[0]-centre[0],2)+pow(llistaPosTCP[1]-centre[1],2)+pow(llistaPosTCP[2]-centre[2],2))"
        global distPunts=radiTCP+sqrt(pow(llistaPosTCP[0]-centre[0],2)+pow(llistaPosTCP[1]-centre[1],2)+pow(llistaPosTCP[2]-centre[2],2))
        $ 82 "distPuntTool≔radiFlange+ sqrt(pow(llistaPosTool[0]-centre[0],2)+pow(llistaPosTool[1]-centre[1],2)+pow(llistaPosTool[2]-centre[2],2))"
        global distPuntTool=radiFlange+ sqrt(pow(llistaPosTool[0]-centre[0],2)+pow(llistaPosTool[1]-centre[1],2)+pow(llistaPosTool[2]-centre[2],2))
        $ 83 "distPuntMig≔radiMig+sqrt(pow(llistaPosMig[0]-centre[0],2)+pow(llistaPosMig[1]-centre[1],2)+pow(llistaPosMig[2]-centre[2],2))"
        global distPuntMig=radiMig+sqrt(pow(llistaPosMig[0]-centre[0],2)+pow(llistaPosMig[1]-centre[1],2)+pow(llistaPosMig[2]-centre[2],2))
        $ 84 "'Si la distancia calculada supera el valor radi, entrem a la condicio perque estem intentant superar el limit.'"
        # 'Si la distancia calculada supera el valor radi, entrem a la condicio perque estem intentant superar el limit.'
        $ 85 "If distPunts≥radi or distPunts≤-radi"
        global thread_flag_85=0
        thread Thread_if_85():
          $ 86 "'Supera el límit amb el TCP'"
          # 'Supera el límit amb el TCP'
          $ 87 "surtTcp≔ True "
          global surtTcp=  True  
          thread_flag_85 = 1
        end
        if (distPunts >= radi  or  distPunts <= -radi):
          global thread_handler_85=run Thread_if_85()
          while (thread_flag_85 == 0):
            if not(distPunts >= radi  or  distPunts <= -radi):
              kill thread_handler_85
              thread_flag_85 = 2
            else:
              sync()
            end
          end
        else:
          thread_flag_85 = 2
        end
        $ 88 "If distPuntTool≥radi or distPuntTool≤-radi"
        global thread_flag_88=0
        thread Thread_if_88():
          $ 89 "'Supera el límit amb el flange de l'eina.'"
          # 'Supera el límit amb el flange de l'eina.'
          $ 90 "surtToolFlange≔ True "
          global surtToolFlange=  True  
          thread_flag_88 = 1
        end
        if (distPuntTool >= radi  or  distPuntTool <= -radi):
          global thread_handler_88=run Thread_if_88()
          while (thread_flag_88 == 0):
            if not(distPuntTool >= radi  or  distPuntTool <= -radi):
              kill thread_handler_88
              thread_flag_88 = 2
            else:
              sync()
            end
          end
        else:
          thread_flag_88 = 2
        end
        $ 91 "If distPuntMig≥radi or distPuntMig≤-radi"
        global thread_flag_91=0
        thread Thread_if_91():
          $ 92 "'Supera el límit amb el punt mig.'"
          # 'Supera el límit amb el punt mig.'
          $ 93 "surtMig≔ True "
          global surtMig=  True  
          thread_flag_91 = 1
        end
        if (distPuntMig >= radi  or  distPuntMig <= -radi):
          global thread_handler_91=run Thread_if_91()
          while (thread_flag_91 == 0):
            if not(distPuntMig >= radi  or  distPuntMig <= -radi):
              kill thread_handler_91
              thread_flag_91 = 2
            else:
              sync()
            end
          end
        else:
          thread_flag_91 = 2
        end
        $ 94 "'Dins un loop que pot estar sense fer res varies vegades, sempres es millor indicar-li un wait.'"
        # 'Dins un loop que pot estar sense fer res varies vegades, sempres es millor indicar-li un wait.'
        $ 95 "Wait: 0.01"
        sleep(0.01)
      end
    end
  end
  threadId_Thread_1 = run Thread_1()
  $ 2 "Robot Program"
  $ 3 "'Definim dues surtTcp i surtToolFlange com a False per indicar quan es passa el limit.'"
  # 'Definim dues surtTcp i surtToolFlange com a False per indicar quan es passa el limit.'
  $ 4 "surtTcp≔ False "
  global surtTcp=  False  
  $ 5 "surtToolFlange≔ False "
  global surtToolFlange=  False  
  $ 6 "surtMig≔ False "
  global surtMig=  False  
  $ 7 "'Indiquem les coordenades del centre de l'esfera.'"
  # 'Indiquem les coordenades del centre de l'esfera.'
  $ 8 "centre≔p[-0.017,-0.392,0.236,0,0,0]"
  global centre=p[-0.017,-0.392,0.236,0,0,0]
  $ 9 "'Indiquem la variable de radi que te l'esfera.'"
  # 'Indiquem la variable de radi que te l'esfera.'
  $ 10 "radi≔0.3"
  global radi=0.3
  $ 11 "'Donem valor als radis del TCP,del punt del flange de l'eina i el punt mig.'"
  # 'Donem valor als radis del TCP,del punt del flange de l'eina i el punt mig.'
  $ 12 "radiTCP≔0.05"
  global radiTCP=0.05
  $ 13 "radiMig≔0.09"
  global radiMig=0.09
  $ 14 "radiFlange≔0.06"
  global radiFlange=0.06
  $ 15 "'Inicialitzem la variable retrocedir.'"
  # 'Inicialitzem la variable retrocedir.'
  $ 16 "retrocedir≔0.001"
  global retrocedir=0.001
  $ 17 "'Activem el moviment lliure.'"
  # 'Activem el moviment lliure.'
  $ 18 "freedrive_mode()"
  freedrive_mode()
  $ 19 "Loop"
  while (True):
    $ 20 "If surtTcp≟ True  or (surtTcp≟ True  and surtToolFlange≟ True )"
    global thread_flag_20=0
    thread Thread_if_20():
      $ 21 "'La condicio es compleix, estem intentant superar la barrera virtual amb el TCP o tant amb el TCP com el flange.'"
      # 'La condicio es compleix, estem intentant superar la barrera virtual amb el TCP o tant amb el TCP com el flange.'
      $ 22 "'Aturem el moviment lliure.'"
      # 'Aturem el moviment lliure.'
      $ 23 "end_freedrive_mode()"
      end_freedrive_mode()
      $ 24 "'Obtenim la posició del TCP per quedar-nos amb els graus dels joints.'"
      # 'Obtenim la posició del TCP per quedar-nos amb els graus dels joints.'
      $ 25 "tcpActual≔get_actual_tcp_pose()"
      global tcpActual= get_actual_tcp_pose ()
      $ 26 "'Generem una variable centre amb els mateixos valors de x, y i z, pero amb els graus dels joints iguals que els TCP de l'eina.'"
      # 'Generem una variable centre amb els mateixos valors de x, y i z, pero amb els graus dels joints iguals que els TCP de l'eina.'
      $ 27 "centre2≔p[centre[0],centre[1],centre[2],tcpActual[3],tcpActual[4],tcpActual[5]]"
      global centre2=p[centre[0],centre[1],centre[2],tcpActual[3],tcpActual[4],tcpActual[5]]
      $ 28 "'Ens movem en direcció al nou centre fins que la distancia entre el centre i el tcp sigui més petit o igual a la del radi - retrocedir.'"
      # 'Ens movem en direcció al nou centre fins que la distancia entre el centre i el tcp sigui més petit o igual a la del radi - retrocedir.'
      $ 29 "MoveL"
      $ 30 "centre2" "breakAfter"
      global move_thread_flag_30=0
      thread move_thread_30():
        enter_critical
        move_thread_flag_30 = 1
        movel(centre2, a=0.15, v=0.025)
        move_thread_flag_30 = 2
        exit_critical
      end
      move_thread_flag_30 = 0
      move_thread_han_30 = run move_thread_30()
      while (True):
        if (point_dist( get_actual_tcp_pose (),centre) <= (radi-radiTCP-retrocedir)):
          kill move_thread_han_30
          stopl(0.15)
          $ 31 "Until (expression)"
          break
        end
        sleep(1.0E-10)
        if (move_thread_flag_30 > 1):
          join move_thread_han_30
          break
        end
        sync()
      end
      $ 32 "'Ara ja tornem a estar a dins l'area de moviment permesa, surtTCP li donem False.'"
      # 'Ara ja tornem a estar a dins l'area de moviment permesa, surtTCP li donem False.'
      $ 33 "surtTcp≔ False "
      global surtTcp=  False  
      $ 34 "'Estem dins la condició que també poden estar tocant els dos, per tant, posem a fals surtToolFlange també.'"
      # 'Estem dins la condició que també poden estar tocant els dos, per tant, posem a fals surtToolFlange també.'
      $ 35 "surtToolFlange≔ False "
      global surtToolFlange=  False  
      $ 36 "'Tornem a activar el moviment.'"
      # 'Tornem a activar el moviment.'
      $ 37 "freedrive_mode()"
      freedrive_mode()
      thread_flag_20 = 1
    end
    if (surtTcp ==   True    or  (surtTcp ==   True    and  surtToolFlange ==   True  )):
      global thread_handler_20=run Thread_if_20()
      while (thread_flag_20 == 0):
        if not(surtTcp ==   True    or  (surtTcp ==   True    and  surtToolFlange ==   True  )):
          kill thread_handler_20
          thread_flag_20 = 2
        else:
          sync()
        end
      end
    else:
      thread_flag_20 = 2
    end
    $ 38 "If surtToolFlange≟ True "
    global thread_flag_38=0
    thread Thread_if_38():
      $ 39 "'La condicio es compleix, estem intentant superar la barrera virtual amb el Flange de l'eina. '"
      # 'La condicio es compleix, estem intentant superar la barrera virtual amb el Flange de l'eina. '
      $ 40 "'Aturem el moviment lliure.'"
      # 'Aturem el moviment lliure.'
      $ 41 "end_freedrive_mode()"
      end_freedrive_mode()
      $ 42 "'Obtenim la posició del flange de l'eina per quedar-nos amb els graus dels joints.'"
      # 'Obtenim la posició del flange de l'eina per quedar-nos amb els graus dels joints.'
      $ 43 "toolFlangeAct≔get_actual_tool_flange_pose()"
      global toolFlangeAct=get_actual_tool_flange_pose()
      $ 44 "'Generem una variable centre amb els mateixos valors de x, y i z, pero amb els graus dels joints iguals que el flange de l'eina.'"
      # 'Generem una variable centre amb els mateixos valors de x, y i z, pero amb els graus dels joints iguals que el flange de l'eina.'
      $ 45 "centr2≔p[centre[0],centre[1],centre[2],toolFlangeAct[3],toolFlangeAct[4],toolFlangeAct[5]]"
      global centr2=p[centre[0],centre[1],centre[2],toolFlangeAct[3],toolFlangeAct[4],toolFlangeAct[5]]
      $ 46 "'Ens movem en direcció el centre fins que la distancia entre el centre i el flange sigui més petit o igual a la del radi - retrocedir.'"
      # 'Ens movem en direcció el centre fins que la distancia entre el centre i el flange sigui més petit o igual a la del radi - retrocedir.'
      $ 47 "MoveL"
      $ 48 "centr2" "breakAfter"
      global move_thread_flag_48=0
      thread move_thread_48():
        enter_critical
        move_thread_flag_48 = 1
        set_tcp(p[0.0,0.0,0.155,0.0,0.0,0.0])
        movel(centr2, a=0.15, v=0.025)
        move_thread_flag_48 = 2
        exit_critical
      end
      move_thread_flag_48 = 0
      move_thread_han_48 = run move_thread_48()
      while (True):
        if (point_dist(get_actual_tool_flange_pose(),centre) <= (radi-radiFlange-retrocedir)):
          kill move_thread_han_48
          stopl(0.15)
          $ 49 "Until (expression)"
          break
        end
        sleep(1.0E-10)
        if (move_thread_flag_48 > 1):
          join move_thread_han_48
          break
        end
        sync()
      end
      $ 50 "'Ara ja tornem a estar a dins l'area de moviment permesa, surtToolFlange li donem False.'"
      # 'Ara ja tornem a estar a dins l'area de moviment permesa, surtToolFlange li donem False.'
      $ 51 "surtToolFlange≔ False "
      global surtToolFlange=  False  
      $ 52 "'Tornem a activar el moviment.'"
      # 'Tornem a activar el moviment.'
      $ 53 "freedrive_mode()"
      freedrive_mode()
      thread_flag_38 = 1
    end
    if (surtToolFlange ==   True  ):
      global thread_handler_38=run Thread_if_38()
      while (thread_flag_38 == 0):
        if not(surtToolFlange ==   True  ):
          kill thread_handler_38
          thread_flag_38 = 2
        else:
          sync()
        end
      end
    else:
      thread_flag_38 = 2
    end
    $ 54 "If surtMig≟ True "
    global thread_flag_54=0
    thread Thread_if_54():
      $ 55 "'La condicio es compleix, estem intentant superar la barrera virtual amb el punt del mig de l'eina. '"
      # 'La condicio es compleix, estem intentant superar la barrera virtual amb el punt del mig de l'eina. '
      $ 56 "'Aturem el moviment lliure.'"
      # 'Aturem el moviment lliure.'
      $ 57 "end_freedrive_mode()"
      end_freedrive_mode()
      $ 58 "'Obtenim la posició del punt del mig de l'eina.'"
      # 'Obtenim la posició del punt del mig de l'eina.'
      $ 59 "tcpActual≔get_actual_tcp_pose()"
      global tcpActual= get_actual_tcp_pose ()
      $ 60 "toolFlangeAct≔get_actual_tool_flange_pose()"
      global toolFlangeAct=get_actual_tool_flange_pose()
      $ 61 "migAct≔p[(tcpActual[0]+toolFlangeAct[0])/2,(tcpActual[1]+toolFlangeAct[1])/2,(tcpActual[2]+toolFlangeAct[2])/2,tcpActual[3],tcpActual[4],tcpActual[5]]"
      global migAct=p[(tcpActual[0]+toolFlangeAct[0])/2,(tcpActual[1]+toolFlangeAct[1])/2,(tcpActual[2]+toolFlangeAct[2])/2,tcpActual[3],tcpActual[4],tcpActual[5]]
      $ 62 "'Generem el vector director per anar des del punt mig de l'eina fins al centre.'"
      # 'Generem el vector director per anar des del punt mig de l'eina fins al centre.'
      $ 63 "vectorDir≔[centre[0]-migAct[0],centre[1]-migAct[1],centre[2]-migAct[2]]"
      global vectorDir=[centre[0]-migAct[0],centre[1]-migAct[1],centre[2]-migAct[2]]
      $ 64 "'Ens movem en direcció el centre fins que la distancia entre el centre i el flange sigui més petit o igual a la del radi - retrocedir.'"
      # 'Ens movem en direcció el centre fins que la distancia entre el centre i el flange sigui més petit o igual a la del radi - retrocedir.'
      $ 65 "MoveL"
      $ 66 "Direction: Base"
      global move_thread_flag_66=0
      thread move_thread_66():
        enter_critical
        move_thread_flag_66 = 1
        local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], vectorDir, 0.005)
        movel(towardsPos, a=0.15, v=0.025)
        move_thread_flag_66 = 2
        exit_critical
      end
      move_thread_flag_66 = 0
      move_thread_han_66 = run move_thread_66()
      while (True):
        sleep(1.0E-10)
        if (move_thread_flag_66 > 1):
          join move_thread_han_66
          $ 67 "Until (distance)"
          break
        end
        sync()
      end
      $ 68 "'Ara ja tornem a estar a dins l'area de moviment permesa, surtMig li donem False.'"
      # 'Ara ja tornem a estar a dins l'area de moviment permesa, surtMig li donem False.'
      $ 69 "surtMig≔ False "
      global surtMig=  False  
      $ 70 "'Tornem a activar el moviment.'"
      # 'Tornem a activar el moviment.'
      $ 71 "freedrive_mode()"
      freedrive_mode()
      thread_flag_54 = 1
    end
    if (surtMig ==   True  ):
      global thread_handler_54=run Thread_if_54()
      while (thread_flag_54 == 0):
        if not(surtMig ==   True  ):
          kill thread_handler_54
          thread_flag_54 = 2
        else:
          sync()
        end
      end
    else:
      thread_flag_54 = 2
    end
    $ 72 "Wait: 0.01"
    sleep(0.01)
  end
end
